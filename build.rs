use convert_case::{Case, Casing};
use std::fs::File;
use std::io::prelude::*;
use xml::{reader::XmlEvent, EventReader};

const EBML_XML: &str = include_str!("ebml.xml");
const EBML_MATROSKA_XML: &str = include_str!("ebml_matroska.xml");

fn variant_to_enum_literal(variant: &str) -> &str {
    match variant {
        "master" => "Master",
        "uinteger" => "Unsigned",
        "integer" => "Signed",
        "string" => "String",
        "binary" => "Binary",
        "utf-8" => "Utf8",
        "date" => "Date",
        "float" => "Float",
        _ => panic!("Variant not expected: {}", variant),
    }
}

fn write_ebml_elements(file: &mut File) -> std::io::Result<()> {
    let mut event_reader = EventReader::from_str(EBML_XML);
    while let Ok(event) = event_reader.next() {
        if event == XmlEvent::EndDocument {
            break;
        }

        if let XmlEvent::StartElement {
            name: tag_name,
            attributes,
            namespace: _,
        } = event
        {
            if tag_name.local_name == "element" {
                for attr in attributes {
                    match attr.name.local_name.as_str() {
                        "name" => {
                            write!(file, "    name = {}, ", attr.value.to_case(Case::Pascal))?
                        }
                        "id" => write!(file, "id = {}, ", attr.value)?,
                        "type" => {
                            writeln!(file, "variant =  {};", variant_to_enum_literal(&attr.value))?
                        }
                        _ => (),
                    }
                }
            }
        }
    }
    Ok(())
}

fn write_matroska_elements(file: &mut File) -> std::io::Result<()> {
    let mut event_reader = EventReader::from_str(EBML_MATROSKA_XML);
    'outer: while let Ok(event) = event_reader.next() {
        if event == XmlEvent::EndDocument {
            break;
        }

        if let XmlEvent::StartElement {
            name: tag_name,
            attributes,
            namespace: _,
        } = event
        {
            if tag_name.local_name == "element" {
                for attr in attributes {
                    match attr.name.local_name.as_str() {
                        "name" => {
                            // Ignore restrictions with duplications
                            match attr.value.as_str() {
                                "EBMLMaxIDLength" | "EBMLMaxSizeLength" => continue 'outer,
                                _ => write!(
                                    file,
                                    "    name = {}, ",
                                    attr.value.to_case(Case::Pascal)
                                )?,
                            }
                        }
                        "id" => write!(file, "id = {}, ", attr.value)?,
                        "type" => {
                            writeln!(file, "variant =  {};", variant_to_enum_literal(&attr.value))?
                        }
                        _ => (),
                    }
                }
            }
        }
    }
    Ok(())
}

fn create_elements_file() -> std::io::Result<()> {
    let mut file = File::create("src/elements.rs")?;

    writeln!(
        file,
        "// DO NOT EDIT! This file is auto-generated by build.rs."
    )?;
    writeln!(file, "// Instead, update ebml.xml and ebml_matroska.xml")?;
    writeln!(file, "use crate::ebml::ebml_elements;")?;
    writeln!(file, "ebml_elements! {{")?;
    write_ebml_elements(&mut file)?;
    write_matroska_elements(&mut file)?;
    writeln!(file, "}}")?;

    Ok(())
}

fn write_matroska_enumerations(file: &mut File) -> std::io::Result<()> {
    let mut event_reader = EventReader::from_str(EBML_MATROSKA_XML);
    let mut last_name = "".to_string();
    let mut last_type = "".to_string();
    let mut first_enum = true;
    let mut reserved_index = 1;
    while let Ok(event) = event_reader.next() {
        if event == XmlEvent::EndDocument {
            break;
        }

        if let XmlEvent::StartElement {
            name: tag_name,
            attributes,
            namespace: _,
        } = event
        {
            match tag_name.local_name.as_str() {
                "element" => {
                    for attr in attributes {
                        match attr.name.local_name.as_str() {
                            "name" => {
                                last_name = attr.value.to_case(Case::Pascal);
                            }
                            "type" => last_type = variant_to_enum_literal(&attr.value).to_string(),
                            _ => (),
                        }
                    }
                }
                "enum" => {
                    if last_type != "Unsigned" {
                        continue;
                    }

                    if !last_name.is_empty() {
                        reserved_index = 1;
                        if !first_enum {
                            writeln!(file, "    }};")?;
                        }
                        writeln!(file, "    {} {{ ", last_name)?;
                        first_enum = false;
                        last_name.clear();
                    }

                    let mut label = "".to_string();
                    let mut value = "".to_string();
                    for attr in attributes {
                        match attr.name.local_name.as_str() {
                            "value" => {
                                value = attr.value;
                            }
                            "label" => {
                                label = attr
                                    .value
                                    .replace(|c: char| !c.is_ascii_alphanumeric(), " ")
                                    .to_case(Case::Pascal);
                                // Hack because identifiers can't start with a number
                                if label == "3Des" {
                                    label = "TripleDes".to_string();
                                }
                                // "Reserved" sometimes repeats in enums
                                else if label == "Reserved" {
                                    label = format!("Reserved{}", reserved_index);
                                    reserved_index += 1;
                                }
                            }
                            _ => (),
                        }
                    }
                    assert!(!label.is_empty());
                    assert!(!value.is_empty());

                    writeln!(file, "        {} = {},", label, value)?;
                }
                _ => (),
            }
        }
    }
    writeln!(file, "}};")?;
    Ok(())
}

fn create_enumerations_file() -> std::io::Result<()> {
    let mut file = File::create("src/enumerations.rs")?;

    writeln!(
        file,
        "// DO NOT EDIT! This file is auto-generated by build.rs."
    )?;
    writeln!(file, "// Instead, update ebml.xml and ebml_matroska.xml")?;
    writeln!(file, "use crate::ebml::ebml_enumerations;")?;
    writeln!(file, "ebml_enumerations! {{")?;
    write_matroska_enumerations(&mut file)?;
    writeln!(file, "}}")?;

    Ok(())
}

fn main() -> std::io::Result<()> {
    println!("cargo:rerun-if-changed=ebml.xml");
    println!("cargo:rerun-if-changed=ebml_matroska.xml");

    create_elements_file()?;
    create_enumerations_file()?;

    Ok(())
}
